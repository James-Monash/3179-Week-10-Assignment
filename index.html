<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>Fujita Tornado Visualisations</title>

  <script src="https://cdn.jsdelivr.net/npm/vega@5"></script>
  <script src="https://cdn.jsdelivr.net/npm/vega-lite@6"></script>
  <script src="https://cdn.jsdelivr.net/npm/vega-embed@6"></script>

  <style>
    body {
      font-family: Helvetica, Arial, sans-serif;
      margin: 16px;
      background: #fff;
      color: #222;
    }

    h1, h2 {
      text-align: center;
      margin-left: 0;
      margin-right: 0;
    }
    
    h1 {
      font-size: 1.8rem;
      margin-bottom: 0.25rem;
      font-weight: 600;
    }
    
    h2 {
      font-size: 1.05rem;
      font-weight: 400;
      color: #6b6b6b;
      margin: 0 0 1rem;
    }

    .vg-tooltip {
      font-family: Helvetica, Arial, sans-serif;
      font-size: 13px;
      background: #fff;
      border: 1px solid #ccc;
      border-radius: 6px;
      padding: 10px 12px;
      box-shadow: 0 4px 12px rgba(0,0,0,0.15);
      line-height: 1.4;
      pointer-events: none;
      z-index: 9999;
    }
    
    /* Tooltip table layout */
    .vg-tooltip table {
      border-collapse: collapse;
      margin: 0;
      width: auto;
    }
    
    /* Label cell — make it bold and black */
    .vg-tooltip .key {
      font-weight: bold !important;
      color: #000 !important;
    }
    
    /* Value cell — make it grey and normal weight */
    .vg-tooltip .value {
      font-weight: normal !important;
      color: #666 !important;
    }

    #top-chart {
      max-width: 800px;
      width: 100%;
      margin: 0 auto 18px auto;
      display: flex;
      justify-content: center;
    }
    #top-chart > iframe,
    #top-chart > div {
      width: 100% !important;
      max-width: 800px;
    }

    .two-column {
      display: flex;
      gap: 16px;
      justify-content: center;
      align-items: flex-start;
      flex-wrap: wrap;
      margin-bottom: 18px;
    }

    .chart-card {
      display: flex;
      align-items: center;     
      justify-content: center;   
      background: #f0f0f0;       
      padding: 12px;
      box-sizing: border-box;
      min-height: 320px;        
    }
    
    /* make sure embedded vega/canvas fills the available area but remains centred */
    .chart-card > svg,
    .chart-card > canvas,
    .chart-card > div {       
      max-width: 100%;
      max-height: 100%;
      display: block;
    }

    /* Combined legend + checkboxes */
    #controls {
      max-width: 1000px;
      margin: 0 auto;
      display: flex;
      gap: 12px;
      align-items: center;
      flex-wrap: wrap;
      margin-bottom: 12px;
    }

    .controls-left-label {
      font-weight: 600;
      margin-right: 6px;
      font-size: 15px;
    }

    .hint {
      text-align: center;
      color: #666;
      margin-top: 0.75rem;
    }

    .legend-checkboxes {
      display: flex;
      gap: 12px;
      align-items: center;
      flex-wrap: wrap;
    }

    .legend-item {
      display: inline-flex;
      gap: 8px;
      align-items: center;
      padding: 6px 8px;
      border-radius: 6px;
      background: rgba(0,0,0,0.02);
      cursor: pointer;
      user-select: none;
      align-items: center;
    }

    .legend-item input[type="checkbox"] {
      width: 16px;
      height: 16px;
      margin: 0;
      accent-color: transparent; /* visual controlled by swatch */
      cursor: pointer;
    }

    .swatch {
      width: 16px;
      height: 16px;
      border-radius: 3px;
      border: 1px solid rgba(0,0,0,0.25);
      display: inline-block;
      flex: 0 0 16px;
    }

    .legend-label {
      font-size: 14px;
      color: #222;
      min-width: 28px;
      text-align: left;
    }

    /* greyed state */
    .legend-item.disabled .swatch {
      background: #ddd !important;
      opacity: 0.9;
    }
    .legend-item.disabled .legend-label {
      color: #9a9a9a;
    }

    footer {
      margin-top: 18px;
      text-align: center;
      color: #666;
      font-size: 13px;
    }
  </style>
</head>
<body>

  <h1>Tornadoes</h1>
  <h2>From the United States to Australia</h2>

  <div id="top-chart"></div>

  <div class="two-column">
    <div id="aus-chart" class="chart-card"></div>
    <div id="us-chart" class="chart-card"></div>
  </div>

  <!-- Combined legend + checkboxes -->
  <div id="controls" aria-label="Fujita rating controls">
    <div class="controls-left-label">Fujita Rating:</div>
    <div id="legend-checkboxes" class="legend-checkboxes" role="group" aria-label="Fujita rating toggles">
      <!-- items injected by JS -->
    </div>
  </div>

  <p class="hint">Toggle ratings to show/hide them on both maps</p>

  <script>
    const topSpecUrl = "fastest_australian_tornadoes.json";

    const ausCsvPattern = "https://raw.githubusercontent.com/James-Monash/3179-Week-10-Assignment/main/Tornado_F{R}_2010_2024_Australia.csv";
    const usCsvPattern  = "https://raw.githubusercontent.com/James-Monash/3179-Week-10-Assignment/main/Tornado_F{R}_2010_2024_America.csv";

    const ausBaseTopo = "https://raw.githubusercontent.com/James-Monash/3179-Week-10-Assignment/main/australia.json";
    const ausGraticules = "https://raw.githubusercontent.com/James-Monash/3179-Week-10-Assignment/main/10_degree_graticules_for_australia.json";

    const usBaseTopo = "https://raw.githubusercontent.com/James-Monash/3179-Week-10-Assignment/main/mainland_united_states.json";
    const usGraticules = "https://raw.githubusercontent.com/James-Monash/3179-Week-10-Assignment/main/10_degree_graticules_for_united_states.json";

    const ratingColors = {
      "F0": "#999999",
      "F1": "#E69F00",
      "F2": "#56B4E9",
      "F3": "#009E73",
      "F4": "#F0E442",
      "F5": "#984ea3"
    };

    const ratings = ["F0","F1","F2","F3","F4","F5"];

    const ausLatField = "Latitude";
    const ausLonField = "Longitude";
    const usLatField = "BEGIN_LAT";
    const usLonField = "BEGIN_LON";

    // selected set (initially all)
    let selectedRatings = new Set(ratings);

    // Basic CSV fetch parser
    async function fetchCsv(url) {
      const r = await fetch(url);
      if (!r.ok) return [];
      const text = await r.text();
      const lines = text.trim().split(/\r?\n/);
      if (lines.length === 0) return [];
      const cols = lines[0].split(",");
      const rows = [];
      for (let i=1;i<lines.length;i++){
        const vals = lines[i].split(",");
        const obj = {};
        for (let j=0;j<cols.length;j++){
          obj[cols[j]] = vals[j] !== undefined ? vals[j] : "";
        }
        rows.push(obj);
      }
      return rows;
    }

    // Legend + checkbox UI
    function buildCombinedLegend() {
      const container = document.getElementById("legend-checkboxes");
      container.innerHTML = "";
      ratings.forEach(r => {
        const item = document.createElement("div");
        item.className = "legend-item";
        item.dataset.rating = r;
        // checkbox
        const cb = document.createElement("input");
        cb.type = "checkbox";
        cb.checked = true;
        cb.value = r;
        cb.setAttribute("aria-label", r + " toggle");
        cb.addEventListener("change", onLegendToggle);
        // swatch
        const sw = document.createElement("span");
        sw.className = "swatch";
        sw.style.background = ratingColors[r];
        // label
        const lbl = document.createElement("span");
        lbl.className = "legend-label";
        lbl.textContent = r;
        // click on whole item toggles checkbox for easier hit target
        item.addEventListener("click", (e) => {
          // avoid double-trigger when clicking checkbox directly
          if (e.target.tagName.toLowerCase() === "input") return;
          cb.checked = !cb.checked;
          cb.dispatchEvent(new Event("change"));
        });
        item.appendChild(cb);
        item.appendChild(sw);
        item.appendChild(lbl);
        container.appendChild(item);
      });
    }

    // Toggle handler: updates selectedRatings and visual appearance then re-render maps
    function onLegendToggle(e) {
      const rating = e.target.value;
      const checked = e.target.checked;
      const item = e.target.closest(".legend-item");
      if (!checked) {
        selectedRatings.delete(rating);
        item.classList.add("disabled");
        // grey swatch and label handled via CSS .disabled
      } else {
        selectedRatings.add(rating);
        item.classList.remove("disabled");
      }
      // re-render maps with new selection
      renderMaps();
    }

    // embed top spec
    async function embedTopSpec(){
      const resp = await fetch(topSpecUrl);
      const spec = await resp.json();
      vegaEmbed("#top-chart", spec, {actions:false, renderer: "canvas"});
    }

    // Build and embed the two maps based on selectedRatings. We dynamically create the vega lite script to only show the relevant dots.
    async function renderMaps() {
      const ausLayers = [
        {
          data: { url: ausBaseTopo, format: { type: "topojson", feature: "ne_50m_admin_1_states_provinces" } },
          mark: { type: "geoshape", fill: "#e0e0e0", stroke: "white", strokeWidth: 1 }
        },
        {
          data: { url: ausGraticules, format: { type: "topojson", feature: "ne_50m_graticules_10" } },
          mark: { type: "geoshape", stroke: "#ccc", strokeWidth: 0.9 }
        }
      ];
    
      const usLayers = [
        {
          data: { url: usBaseTopo, format: { type: "topojson", feature: "ne_50m_admin_1_states_provinces" } },
          mark: { type: "geoshape", fill: "#e0e0e0", stroke: "white", strokeWidth: 1 }
        },
        {
          data: { url: usGraticules, format: { type: "topojson", feature: "ne_50m_graticules_10" } },
          mark: { type: "geoshape", stroke: "#ccc", strokeWidth: 0.9 }
        }
      ];
    
      // append per-rating layers only for selected ratings
      for (const r of ratings) {
        if (!selectedRatings.has(r)) continue;
    
        const ausUrl = ausCsvPattern.replace("{R}", r.slice(1));
        const usUrl  = usCsvPattern.replace("{R}", r.slice(1));
        const [ausRows, usRows] = await Promise.all([fetchCsv(ausUrl), fetchCsv(usUrl)]);
    
        const ausValues = ausRows.map(row => {
          const out = Object.assign({}, row);
          if (out[ausLatField] !== undefined) out[ausLatField] = parseFloat(out[ausLatField]);
          if (out[ausLonField] !== undefined) out[ausLonField] = parseFloat(out[ausLonField]);
          out.TOR_F_SCALE = out.TOR_F_SCALE || r;
          return out;
        });
    
        const usValues = usRows.map(row => {
          const out = Object.assign({}, row);
          if (out[usLatField] !== undefined) out[usLatField] = parseFloat(out[usLatField]);
          if (out[usLonField] !== undefined) out[usLonField] = parseFloat(out[usLonField]);
          out.TOR_F_SCALE = out.TOR_F_SCALE || r;
          return out;
        });
    
        // note: tooltip encoding explicitly set to show only the Fujita rating
        ausLayers.push({
          data: { values: ausValues },
          mark: { type: "point", filled: true, size: 30 },
          encoding: {
            longitude: { field: ausLonField, type: "quantitative" },
            latitude: { field: ausLatField, type: "quantitative" },
            color: { value: ratingColors[r] },
            tooltip: [{ title: "Fujita rating", field: "TOR_F_SCALE", type: "nominal" }]
          }
        });
    
        usLayers.push({
          data: { values: usValues },
          mark: { type: "point", filled: true, size: 30 },
          encoding: {
            longitude: { field: usLonField, type: "quantitative" },
            latitude: { field: usLatField, type: "quantitative" },
            color: { value: ratingColors[r] },
            tooltip: [{ title: "Fujita rating", field: "TOR_F_SCALE", type: "nominal" }]
          }
        });
      } // end for-loop
    
      // build specs AFTER layers are complete
      const ausSpec = {
        $schema: "https://vega.github.io/schema/vega-lite/v6.json",
        width: 800, height: 600, background: "#c6dbef",
        projection: { type: "mercator", center: [134, -25], scale: 700 },
        title: { text: "Australian Tornadoes (2010–2024)", anchor: "start", fontSize: 20, font: "Helvetica", color: "#333", subtitle: "Color-coded by Fujita rating" },
        layer: ausLayers,
        config: { legend: { labelFontSize: 12, titleFontSize: 14 }, view: { stroke: "transparent" } }
      };
    
      const usSpec = {
        $schema: "https://vega.github.io/schema/vega-lite/v6.json",
        width: 800, height: 600, background: "#c6dbef",
        projection: { type: "mercator", center: [-98, 38], scale: 700 },
        title: { text: "U.S. Tornadoes (2010–2024)", anchor: "start", fontSize: 20, font: "Helvetica", color: "#333", subtitle: "Color-coded by Fujita rating" },
        layer: usLayers,
        config: { legend: { labelFontSize: 12, titleFontSize: 14 }, view: { stroke: "transparent" } }
      };
    
      const embedOpts = { actions: false, renderer: "canvas" };
    
      // clear containers once, then embed the completed specs
      document.getElementById("aus-chart").innerHTML = "";
      document.getElementById("us-chart").innerHTML = "";
    
      // minimal embeds (no try/catch, no title removal)
      ausEmbed = await vegaEmbed("#aus-chart", ausSpec, embedOpts);
      usEmbed  = await vegaEmbed("#us-chart", usSpec,  embedOpts);
    }

    // init
    async function init() {
      buildCombinedLegend();
      await embedTopSpec();
      await renderMaps();
    }

    init();
  </script>
</body>
</html>
